outlets = 1;var vdim = [320,240];var framearray = new Array();var outslab = new JitterObject("jit.gl.slab","compositor");outslab.inputs = 2;outslab.colormode = "uyvy";outslab.file = "co.normal.jxs";outslab.param("amount",0.);var outframeA = 0;var outframeB = 0;var tweenfade = 0.;var recmode = 0;var rechead = 0;var loopmode = 1;var playspeed = 1.0;var playmode = 0;var playhead = 0;var framecount = 60;var in_point = 0;var out_point = framecount;var vcount = 0;initialmaxframes(framecount);function jit_matrix(in_name){	if (recmode==1) {		storeframe(in_name)	}	if (playmode==1){		playframes();	}	else {		outlet(0,"bang");			}}//MSG IN - store and/or retrive frames. also the clock!function record(){	recmode = 1;}//MSG IN - recmode onfunction stop_record (){	recmode = 0;}//MSG IN - recmode offfunction reset_record (){	rechead = 0;}//MSG IN - reset record headfunction storeframe(in_name){	framearray[rechead].frommatrix(in_name);	out_point = rechead;	rechead++;	if (rechead >= framecount) {		recmode = 0;		reset_record();	}}//store frame and advance recheadfunction play(newspeed){	if(typeof(newspeed)=="undefined")	{		playmode = 1;	}	else	{		playspeed = newspeed;		playmode = 1;	}}//MSG IN - turn playmode on and optionally set playspeedfunction stop_play (){	playmode = 0;}//MSG IN - playmode offfunction reset_play (){	if(playspeed<0.0)	{		playhead = out_point;	}	else	{		playhead = in_point;	}}//MSG IN - reset play headfunction jam (toframe){	playhead = toframe;	playframes();}//MSG IN - set playheadfunction set_in (new_in_point){	in_point = new_in_point;	if(in_point<0)	{		in_point = 0;	}	if(in_point>out_point)	{		in_point = out_point;	}}//MSG IN - set in_pointfunction set_out (new_out_point){	out_point = new_out_point;	if(out_point > framecount)	{		out_point = framecount;	}	if(out_point<in_point)	{		out_point = in_point;	}}//MSG IN - set in_pointfunction advance_playhead (){	if (loopmode)	{		playhead+=playspeed;		var relative_playhead = playhead - in_point;		var clip_length = out_point - in_point;		if (relative_playhead > clip_length || relative_playhead < 0)		{			reset_play();		}	}	else	{		playhead+=playspeed;		if (playhead>=out_point||playhead<=0)		{			playmode = 0;		}	}}//advance playhead in accordance with loopmode and loop pointsfunction playframes() {	if(playspeed==1.0)	{		tweenfade = 1.0;	}	else	{		tweenfade = 0.5-(playhead - Math.round(playhead));			}	outframeA = (Math.round(playhead))%framecount;	outframeB = (outframeA + 1.0)%framecount;	outslab.param("amount",tweenfade);	outslab.activeinput = 1;	outslab.jit_matrix(framearray[outframeA].name);	outslab.activeinput = 0;	outslab.jit_matrix(framearray[outframeB].name);	outslab.draw();		outlet(0,"jit_gl_texture",outslab.capture);						//	outlet(0,"jit_matrix",outmatrix.name);	advance_playhead();}//MSG OUT - send out frame and advance playheadfunction loop (c){	loopmode = c;	if (loopmode<0||loopmode>1)	{		loopmode = 1;	}}//MSG IN - set loopmodefunction speed (c){	playspeed = c;}//MSG IN - set playspeedfunction dim(width,height){	vdim[0] = width;	vdim[1] = height;	for (i=0;i<vcount;i++) {		framearray[i].dim = vdim;	}	dummymatrix.dim = vdim;	outmatrix.dim = vdim;}//MSG IN - set width and heigh of all jit.matrix objectsfunction freeoldbuffer(){	vcount = framecount;	for (var i=0;i<vcount;i++) {		framearray[i].freepeer();	}}//dispose of old bufferfunction maxframes(c){	freeoldbuffer();	if (c<1)		c = 1;	vcount = c;	for (var i=0;i<vcount;i++) {		framearray[i] = new JitterMatrix(4,"char",vdim[0],vdim[1]);		framearray[i].setall([128,16,128,16]);	}	framecount = c;	in_point = 0;	out_point = framecount;}	//reallocate buffer to new sizefunction initialmaxframes(c){	if (c<1)		c = 1;	vcount = c;	for (var i=0;i<vcount;i++) {		framearray[i] = new JitterMatrix(4,"char",vdim[0],vdim[1]);		framearray[i].setall([128,16,128,16]);	}}	//initial buffer allocation